엔티티 설계시 주의할 점

엔티티에는 가급적 Setter를 사용하지 말 것.

모든 연관관계는 지연로딩으로 설정할 것.(중요)
즉시로딩(EAGER)은 예측하기 어렵고, 어떤 SQL이 실행될 지 추적하기가 무척 어렵다.
EAGER로 조회할 경우 Entity에 연관된 데이터를 모조리 가져온다.(성능문제)

실무에서 모든 연관관계는 지연로딩(LAZY)로 설정해야 한다.
연관된 엔티티를 함께 DB에서 조회해야 하면, fetch join을 사용할 것.

@XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야 한다.
@XToMany(ManyToOne, ManyToMany) 관계는 기본이 지연로딩.
디폴트
@ManyToOne : EAGER
@OneToMany : LAZY

생성자를 통해서 컬렉션을 초기화하기보단, List<T> list = new ArrayList<>(); 로 사용하는 것이 좋다.
Hibernate는 엔티티를 영속화 할 때, 컬렉션을 감싸서 Hibernate가 제공하는 내장 컬렉션으로 변경한다.
getOrders()처럼 임의의 메서드에서 컬렉션을 잘못 생성하면 Hibernate 내부 매커니즘에 문제가 발생할 수 있다.
따라서 필드레벨에서 생성하는 것이 가장 안전하고 코드가 간결하다.
em.persist(); <- 영속화 할 경우 java.util.ArrayList에서 org.hibernate.collection.internal.PersistentBag으로 바뀜
Hibernate가 변경한 컬렉션을 다시 set으로 수정할 경우 Hibernate의 내부 매커니즘으로 작동하지 않아서 문제가 발생할 수 있다.
가장 좋은 방법은 컬렉션은 가급적 변경하지 않고 있는 값으로 사용하는 것이 좋다.







테이블, 컬럼명 생성전략
스프링 부트는 SpringPhysicalNamingStrategy
스프링 부트 신규 설정(엔티티(필드) -> 테이블(컬럼))
1. 카멜케이스 -> 언더스코어 (memberPoint -> member_point)
2. .(점) -> _(언더스코어)
3. 대문자 -> 소문자

논리명 생성 :  명시적으로 컬럼, 테이블 명을 직접 적지 않으면 ImplicitNamingStrategy 사용
            `spring.jpa.hibernate.naming.implicit-strategy` : 테이블이나, 컬럼명을 명시하지 않을 떄 논리명 적용.
물리명 적용 :  `spring.jpa.hibernate.naming.physical-strategy` 모든 논리명에 적용됨. 실제 테이블에 적용
            username -> usernm 등으로 회사 룰로 바꿀 수 있음.


Long -> bigint, LocalDateTime ->timestamp





JPAQ : JPA가 제공하는 쿼리