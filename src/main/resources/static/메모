엔티티 설계시 주의할 점

엔티티에는 가급적 Setter를 사용하지 말 것.

엔티티에는 핵심 비즈니스 로직만 넣을 것.
화면에 대한 로직은 따로 작성하거나 DTO를 작성할 것.
엔티티는 굉장히 여러 곳에서 사용하는데 엔티티를 손대서 api 스펙이 변해버리는 문제가 발생하기 때문에,
api 스펙을 위한 DTO를 따로 만들어야 한다.
- api와 엔티티를 1:1 관계로 설정되지 않도록 할 것
- 엔티티 정보를 유출하지 않도록

**api 요청 스펙에 맞워서 DTO를 사용할 것!!



애플리케이션을 만들 경우 엔티티를 절대 웹으로 반환하면 안된다.
엔티티는 스펙이다. : 엔티티의 로직이 변할경우 스펙이 변해서 오류가 생길 수 있다.

모든 연관관계는 지연로딩으로 설정할 것.(중요)
즉시로딩(EAGER)은 예측하기 어렵고, 어떤 SQL이 실행될 지 추적하기가 무척 어렵다.
EAGER로 조회할 경우 Entity에 연관된 데이터를 모조리 가져온다.(성능문제)

실무에서 모든 연관관계는 지연로딩(LAZY)로 설정해야 한다.
연관된 엔티티를 함께 DB에서 조회해야 하면, fetch join을 사용할 것.

@XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야 한다.
@XToMany(ManyToOne, ManyToMany) 관계는 기본이 지연로딩.
디폴트
@ManyToOne : EAGER
@OneToMany : LAZY

생성자를 통해서 컬렉션을 초기화하기보단, List<T> list = new ArrayList<>(); 로 사용하는 것이 좋다.
Hibernate는 엔티티를 영속화 할 때, 컬렉션을 감싸서 Hibernate가 제공하는 내장 컬렉션으로 변경한다.
getOrders()처럼 임의의 메서드에서 컬렉션을 잘못 생성하면 Hibernate 내부 매커니즘에 문제가 발생할 수 있다.
따라서 필드레벨에서 생성하는 것이 가장 안전하고 코드가 간결하다.
em.persist(); <- 영속화 할 경우 java.util.ArrayList에서 org.hibernate.collection.internal.PersistentBag으로 바뀜
Hibernate가 변경한 컬렉션을 다시 set으로 수정할 경우 Hibernate의 내부 매커니즘으로 작동하지 않아서 문제가 발생할 수 있다.
가장 좋은 방법은 컬렉션은 가급적 변경하지 않고 있는 값으로 사용하는 것이 좋다.

JPA는 다양한 성능 튜닝 옵션을 제공하고 있다.
튜닝 관련 지식이 없기 때문에 제대로 사용하지 못하여 생기는 문제이다.




변경 감지와 병합(merge)

- 변경감지의 메커니즘
    - find로 찾은 엔티티는 영속상태의 엔티티이다.
    - 트랜잭션 안에서 엔티티를 조회해야 영속 상태로 조회된다. (영속 상태의 엔티티만 변경감지 할 수 있다.)
      찾아온 영속 상태의 엔티티의 값을 변경하면 메소드가 끝난 시점에 flush가 발생하면서 변경감지(dirty Checking)을 통해서 UPDATE된다.

    메소드가 끝나면 스프링의 Trasactional에 의해서 Transaction이 커밋됌.
    커밋이 되면 JPA는 flush를 날림.
    flush는 영속성 컨텍스트에 있는 엔티티 중에 변경된 게 있는지 찾음.
    바뀐 값을 DB에 UPDATE

    - 변경감지의 경우 바뀐 값만 update가 된다.

- merge의 메커니즘
    파라미터로 날아온 준영속상태의 엔티티를 영속성 엔티티에서 찾음.
    보통은 없으므로 DB에서 새로운 엔티티를 조회.
    찾아온 새로운 엔티티에 파라미터로 날아온 엔티티를 밀어넣음.(전체)

    단점 : 비어있는 경우 null값으로도 다 바뀔 수 있다.
          보통의 경우 몇 개의 컬럼만 변경되는데 merge를 사용할 경우 merge로 밀어넣는 데이터에 빈 값마저 다 밀어넣기 때문에 조심해야 한다.


-merge는 전체 UPDATE
-변경감지는 바뀐 값만 UPDATE

** merge는 사용하지 않는 것이 좋다. 변경감지를 사용하라.
** 꼭 변경감지를 사용할 것.


- Controller에서 어설프게 Entity를 만들지 말 것.
- 필요한 데이터만 가지고 오는 것이 좋다.
- 데이터가 조금 많다면 DTO를 새로 생성할 것.




테이블, 컬럼명 생성전략
스프링 부트는 SpringPhysicalNamingStrategy
스프링 부트 신규 설정(엔티티(필드) -> 테이블(컬럼))
1. 카멜케이스 -> 언더스코어 (memberPoint -> member_point)
2. .(점) -> _(언더스코어)
3. 대문자 -> 소문자

논리명 생성 :  명시적으로 컬럼, 테이블 명을 직접 적지 않으면 ImplicitNamingStrategy 사용
            `spring.jpa.hibernate.naming.implicit-strategy` : 테이블이나, 컬럼명을 명시하지 않을 떄 논리명 적용.
물리명 적용 :  `spring.jpa.hibernate.naming.physical-strategy` 모든 논리명에 적용됨. 실제 테이블에 적용
            username -> usernm 등으로 회사 룰로 바꿀 수 있음.


Long -> bigint, LocalDateTime ->timestamp





JPAQ : JPA가 제공하는 쿼리
준영속엔티티 : JPA가 관리하지 않는 엔티티
            - ID가 세팅이 돼있는 엔티티(JPA에 한 번 들어갔다 나온 엔티티)
            - new를 통해 만든 엔티티






개발 기능 정리

회원 기능
    - 회원 등록
    - 회원 조회

상품 기능
    - 상품 등록
    - 상품 수정
    - 상품 조회
주문 기능
    - 상품 주문
    - 주문 내역 조회
    - 주문 취소


추 후 개발할 것.
- 로그인과 권한관리
- 파라미터 검증과 예외처리 단순화
- 배송정보





애플리케이션 아키텍처

계층형 구조
    컨트롤러 -> 서비스 -> 레포지토리 -> 데이터베이스
    컨트롤러, 웹 : 웹 계층
    서비스 : 비즈니스 로직, 트랜잭션 처리
    레포지토리 : JPA를 직접 사용하는 계층, 엔티티 매니저 사용
    도메인 : 엔티티가 모여 있는 계층, 모든 계층(웹 계층, 서비스 계층, 레포지토리 계층)에서 사용

패키지 구조
jpabook.jpashop
    - domain
    - exception
    - repository
    - service
    - web

간단한 것들은 Controller에서 바로 Mapper를 호출하는 유연한 구조로 작성한다.
간단하게 조회하는 것들도 모두 Controller ->Service -> Repository 구조로 가져가면 실용적인 측면에서 좋진 않다.

개발 순서 : 서비스, 레포지토리 계층을 개발하고, 테스트 케이스를 작성해서 검증, 마지막에 웹 계층 적용
         서비스, 레포지토리 계층을 먼저 개발 후 테스트 적용


웹 계층 개발

변경 감지와 병합 : 어떻게 데이터를 수정하는 것이 올바른 방법인가 ?




Thymeleaf
 - 타임리프 사이트에서 레이아웃 내용 참고할 것.
 - Hierarchical-style layout을 사용하면 include해서 헤더 푸터를 붙여넣는 중복 코드를 사용하지 않아도 자동으로 넣어줄 수 있음.
 - ?를 사용하면 null일 경우 값 안 찍음.


웹 페이지 개발 시 꿀 팁
    - Command + Shift + F4 누르면 자동 리컴파일 빌드



단축키 메모
- Command + E           : 최근에 열었던 파일 목록
- Command + Shift + F4  : 자동 리컴파일 빌드
- Command + Option + M  : 생성자를 메서드로 묶음
- Command + shift + T   : 테스트와 테스트 아닌 소스 화면 이동
- Command + N           : 생성자, Getter, Setter 등 생성 단축키
- Shift + Command + C     : 파일 경로 복사
- Option + Command + Enter : 자동완성



실무자의 역량

실무자는 기능 개발을 넘어서 기술 문제를 해결할 수 있어야한다.
단순히 기능을 작동하도록 하는 것이 아니라 성능도 고려하여 개발하여야 한다.


패키지
api패키지로 분리하는 이유는
공통으로 예외처리를 하거나 할 때
공통처리 관점에 차이가 있기 때문에 따로 분리를 함.

어노테이션
@Valid : @Valid를 사용하면 자바X 벨리데이션 관련된 내용들이 자동으로 벨리데이션 된다.
@RequestBody : @RequestBody를 사용하면 API 통신을 하면 JSON으로만 사용하는데 Json으로 온 Body를 객체에 그대로 매핑에서 넣어줌
@NotEmpty : 값이 비어있으면 안된다.


자바X 벨리데이션
@NotEmpty : 값이 비어있는 지 체크